Призначення шаблону проєктування Стратегія
Існують системи, поведінка яких визначається відповідно до певного роду алгоритмів. Всі вони подібні між собою: призначені для вирішення спільних задач, мають однаковий інтерфейс для користування, але відрізняються тільки «поведінкою», тобто реалізацією. Користувач, налаштувавши програму на потрібний алгоритм — отримує потрібний результат.
Приклад. Є програма(інтерфейс) через яку обраховується ціна на товар для покупців у яких є знижка та ціна за сезонною знижкою — обираємо необхідний алгоритм. Об'єктно-орієнтований дизайн такої програми будується на ідеї використання поліморфізму. Результатом є набір «класів-родичів» — у яких єдиний інтерфейс та різна реалізація алгоритмів.
Недоліками такого алгоритму є те, що реалізація жорстко прив'язана до підкласу, що ускладнює внесення змін.
Вирішенням даної проблеми є використання патерну Стратегія (Strategy).
Переваги та недоліки
Переваги
Можливість позбутися умовних операторів.
Клієнт може вибирати найбільш влучну стратегію залежно від вимог щодо швидкодії і пам'яті.
Недоліки
Збільшення кількості об'єктів.
Клієнт має знати особливості реалізацій стратегій для вибору найбільш вдалої.

#include <iostream>

using namespace std;

// загальний спосіб вирішення проблеми
struct NameStrategy
{
	virtual void greet() = 0;
};
// Конкретні рецепти вирішення
struct SayHi : public NameStrategy
{
	void greet()
	{
		cout << " Hi!How is it going ? " << endl;
	}
};
struct Ignore : public NameStrategy
{
	void greet()
	{
		cout << " (Pretend I do not see you)" << endl;
	}
};
struct Admission : public NameStrategy
{
	void greet()
	{
		cout << " I am sorry.I forgot your name." << endl;
	}
};
// Контекст керує стратегією («Посередник»)
// «Стан» - якщо можлива зміна стратегії за життя контексту
class Context
{
private:
	NameStrategy& strategy;
public:
	Context(NameStrategy& strat) : strategy(strat) {}
	void greet() { strategy.greet(); } // постійний код
};
void main()
{
	SayHi sayhi;
	Ignore ignore;
	Admission admission;
	Context c1(sayhi), c2(ignore), c3(admission);
	c1.greet();
	c2.greet();
	c3.greet();
}
